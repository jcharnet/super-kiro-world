// ===== GAME CONSTANTS =====
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const LEVEL_WIDTH = 4000;
const GRAVITY = 0.5;
const JUMP_POWER = 12;
const MOVE_SPEED = 5;
const FRICTION = 0.85;
const MAX_TIME_WARPS = 3;
const TIME_WARP_HISTORY_SECONDS = 2.5;
const CAMERA_LERP = 0.1;
const MAX_PARTICLES = 500;

// ===== CANVAS SETUP =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'playing'; // 'playing', 'gameOver', 'levelComplete'
let score = 0;
let highScore = 0;
let confettiTriggered = false;
let lives = 3;
let timeWarpsRemaining = MAX_TIME_WARPS;
let levelStartTime = Date.now();
let totalCollectibles = 0;
let screenShake; // Will be initialized after class definitions

// ===== KEYBOARD INPUT =====
const keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    keys[e.code] = true;
    
    if (e.key === 'r' || e.key === 'R') {
        if (gameState === 'gameOver' || gameState === 'levelComplete') {
            restartGame();
        }
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
    keys[e.code] = false;
});

// ===== SCORE MANAGER =====
class ScoreManager {
    constructor() {
        this.storageKey = 'superKiroWorld_gameData';
        this.playerName = 'Player';
        this.gameHistory = [];
        this.highScores = {};
        this.loadFromStorage();
    }
    
    loadFromStorage() {
        try {
            const data = localStorage.getItem(this.storageKey);
            if (data) {
                const parsed = JSON.parse(data);
                this.playerName = parsed.playerName || 'Player';
                this.gameHistory = parsed.gameHistory || [];
                this.highScores = parsed.highScores || {};
            }
        } catch (error) {
            console.error('Failed to load game data from Local Storage:', error);
            // Initialize with empty data on error
            this.gameHistory = [];
            this.highScores = {};
        }
    }
    
    saveToStorage() {
        try {
            const data = {
                playerName: this.playerName,
                gameHistory: this.gameHistory,
                highScores: this.highScores
            };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (error) {
            console.error('Failed to save game data to Local Storage:', error);
            
            // Handle quota exceeded error
            if (error.name === 'QuotaExceededError') {
                // Keep only last 100 entries
                this.gameHistory = this.gameHistory.slice(-100);
                try {
                    const data = {
                        playerName: this.playerName,
                        gameHistory: this.gameHistory,
                        highScores: this.highScores
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                    console.log('Trimmed game history to fit storage quota');
                } catch (retryError) {
                    console.error('Still failed after trimming history:', retryError);
                }
            }
        }
    }
    
    loadGameHistory() {
        return this.gameHistory;
    }
    
    saveGameSession(session) {
        // Add timestamp if not present
        if (!session.timestamp) {
            session.timestamp = new Date().toISOString();
        }
        
        // Add to history
        this.gameHistory.push(session);
        
        // Update high score for this player
        const playerName = session.player;
        if (!this.highScores[playerName] || session.score > this.highScores[playerName]) {
            this.highScores[playerName] = session.score;
        }
        
        // Save to storage
        this.saveToStorage();
    }
    
    getHighScore(playerName) {
        if (!playerName) {
            playerName = this.playerName;
        }
        return this.highScores[playerName] || 0;
    }
    
    getCurrentPlayerName() {
        return this.playerName;
    }
    
    setPlayerName(name) {
        if (name && name.trim()) {
            this.playerName = name.trim();
            this.saveToStorage();
        }
    }
}

// ===== PARTICLE POOL =====
class ParticlePool {
    constructor(maxSize = 500) {
        this.pool = [];
        this.active = [];
        this.maxSize = maxSize;
        
        // Pre-allocate particles
        for (let i = 0; i < maxSize; i++) {
            this.pool.push(new Particle(0, 0, '#ffffff', 0, 0, 0));
        }
    }
    
    acquire(x, y, color, vx, vy, life, type = 'default', rotation = 0, rotationSpeed = 0) {
        let particle;
        
        if (this.pool.length > 0) {
            // Reuse from pool
            particle = this.pool.pop();
            particle.x = x;
            particle.y = y;
            particle.color = color;
            particle.vx = vx;
            particle.vy = vy;
            particle.life = life;
            particle.maxLife = life;
            particle.type = type;
            particle.rotation = rotation;
            particle.rotationSpeed = rotationSpeed;
        } else {
            // Create new if pool empty
            particle = new Particle(x, y, color, vx, vy, life, type, rotation, rotationSpeed);
        }
        
        this.active.push(particle);
        return particle;
    }
    
    release(particle) {
        const index = this.active.indexOf(particle);
        if (index > -1) {
            this.active.splice(index, 1);
            if (this.pool.length < this.maxSize) {
                this.pool.push(particle);
            }
        }
    }
    
    update() {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const particle = this.active[i];
            particle.update();
            
            if (particle.life <= 0) {
                this.release(particle);
            }
        }
    }
    
    render(ctx, camera) {
        for (const particle of this.active) {
            particle.render(ctx, camera);
        }
    }
    
    clear() {
        while (this.active.length > 0) {
            this.release(this.active[0]);
        }
    }
}

// ===== SCREEN SHAKE SYSTEM =====
class ScreenShake {
    constructor() {
        this.intensity = 0;
        this.duration = 0;
        this.maxDuration = 0;
    }
    
    trigger(intensity, duration) {
        // Only override if new shake is stronger
        if (intensity > this.intensity) {
            this.intensity = intensity;
            this.duration = duration;
            this.maxDuration = duration;
        }
    }
    
    update() {
        if (this.duration > 0) {
            this.duration -= 1 / 60; // Assuming 60 FPS
            
            // Decay intensity over time
            const progress = this.duration / this.maxDuration;
            this.intensity *= progress;
            
            if (this.duration <= 0) {
                this.intensity = 0;
                this.duration = 0;
            }
        }
    }
    
    getOffset() {
        if (this.intensity <= 0) {
            return { x: 0, y: 0 };
        }
        
        // Use sine wave for smooth shake
        const angle = Math.random() * Math.PI * 2;
        const magnitude = this.intensity;
        
        return {
            x: Math.cos(angle) * magnitude,
            y: Math.sin(angle) * magnitude
        };
    }
}

// Initialize screen shake after class definition
screenShake = new ScreenShake();

// ===== PARTICLE SYSTEM =====
class Particle {
    constructor(x, y, color, vx, vy, life, type = 'default', rotation = 0, rotationSpeed = 0) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.type = type;
        this.rotation = rotation;
        this.rotationSpeed = rotationSpeed;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Apply gravity based on particle type
        if (this.type === 'confetti') {
            this.vy += 0.3; // Confetti falls with gravity
            this.rotation += this.rotationSpeed;
        } else if (this.type === 'sparkle') {
            this.vy += 0.1; // Sparkles float gently
        } else {
            this.vy += 0.2; // Default gravity
        }
        
        this.life--;
    }
    
    render(ctx, camera) {
        const alpha = this.life / this.maxLife;
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        if (this.type === 'confetti') {
            // Render confetti as rotating rectangles
            ctx.translate(renderX, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillRect(-3, -6, 6, 12);
        } else if (this.type === 'sparkle') {
            // Render sparkles as stars
            ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.beginPath();
            ctx.arc(renderX, this.y, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Add sparkle glow
            ctx.strokeStyle = this.color + Math.floor(alpha * 128).toString(16).padStart(2, '0');
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(renderX - 4, this.y);
            ctx.lineTo(renderX + 4, this.y);
            ctx.moveTo(renderX, this.y - 4);
            ctx.lineTo(renderX, this.y + 4);
            ctx.stroke();
        } else if (this.type === 'trail') {
            // Render trail particles as small circles
            ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.beginPath();
            ctx.arc(renderX, this.y, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'explosion') {
            // Render explosion particles as squares
            ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillRect(renderX - 2, this.y - 2, 4, 4);
        } else {
            // Default rendering
            ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillRect(renderX, this.y, 3, 3);
        }
        
        ctx.restore();
    }
}

const particles = [];

// ===== PARTICLE FACTORY =====
class ParticleFactory {
    static createTrailParticle(x, y, vx, vy) {
        const life = 15;
        return new Particle(x, y, '#790ECB', vx, vy, life, 'trail');
    }
    
    static createExplosionParticles(x, y, count = 12) {
        const explosionParticles = [];
        const colors = ['#ff6b6b', '#ffd93d', '#ff8c42'];
        
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            const speed = 3 + Math.random() * 2;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const life = 25;
            
            explosionParticles.push(new Particle(
                x, y, color,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                life,
                'explosion'
            ));
        }
        
        return explosionParticles;
    }
    
    static createSparkleParticles(x, y, count = 8) {
        const sparkleParticles = [];
        const colors = ['#ffffff', '#ffff00', '#790ECB'];
        
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            const speed = 1 + Math.random() * 2;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const life = 30;
            
            // Sparkles have upward and outward velocity
            const vx = Math.cos(angle) * speed;
            // Ensure vy is always negative (upward) by using absolute value
            const vy = -(Math.abs(Math.sin(angle) * speed) + 1);
            
            sparkleParticles.push(new Particle(
                x, y, color,
                vx, vy,
                life,
                'sparkle'
            ));
        }
        
        return sparkleParticles;
    }
    
    static createConfettiParticles(count = 50) {
        const confettiParticles = [];
        const colors = ['#790ECB', '#ff6b6b', '#4ecdc4', '#ffd93d', '#95e1d3'];
        
        for (let i = 0; i < count; i++) {
            // Spawn across screen width
            const x = Math.random() * 800;
            const y = -20 - Math.random() * 100; // Start above screen
            const vx = (Math.random() - 0.5) * 4;
            const vy = Math.random() * 2;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const life = 120;
            const rotation = Math.random() * Math.PI * 2;
            const rotationSpeed = (Math.random() - 0.5) * 0.2;
            
            confettiParticles.push(new Particle(
                x, y, color,
                vx, vy,
                life,
                'confetti',
                rotation,
                rotationSpeed
            ));
        }
        
        return confettiParticles;
    }
}

function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 2 + Math.random() * 2;
        particles.push(new Particle(
            x, y, color,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 2,
            30 + Math.random() * 20
        ));
    }
}

// ===== POWER-UP SYSTEM =====
class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 30;
        this.type = type; // 'speed', 'invincibility', 'doubleJump', 'slowMotion'
        this.collected = false;
        this.respawnTimer = 0;
        this.respawnDuration = 10; // seconds
        this.glowIntensity = 0.5;
        this.floatOffset = 0;
        this.floatSpeed = 2;
        this.originalY = y;
    }
    
    update(deltaTime, player) {
        if (this.collected) {
            // Update respawn timer
            this.respawnTimer += deltaTime;
            if (this.respawnTimer >= this.respawnDuration) {
                this.collected = false;
                this.respawnTimer = 0;
            }
            return;
        }
        
        // Floating animation
        this.floatOffset = Math.sin(Date.now() / 1000 * this.floatSpeed) * 10;
        
        // Glow effect based on proximity to player
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 100) {
            this.glowIntensity = 0.8 + Math.sin(Date.now() / 100) * 0.2;
        } else {
            this.glowIntensity = 0.5 + Math.sin(Date.now() / 200) * 0.1;
        }
        
        // Check collision with player
        if (this.isColliding(player)) {
            this.collect(player);
        }
    }
    
    isColliding(player) {
        const currentY = this.originalY + this.floatOffset;
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < currentY + this.height &&
               player.y + player.height > currentY;
    }
    
    collect(player) {
        this.collected = true;
        this.respawnTimer = 0;
        
        // Trigger power-up effect through PowerUpManager
        if (window.powerUpManager) {
            window.powerUpManager.activatePowerUp(this.type, player);
        }
        
        // Play collection sound
        if (window.audioManager) {
            audioManager.playSound('collect');
        }
        
        // Spawn collection particles
        if (window.particlePool) {
            const color = this.getColor();
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 2 + Math.random() * 2;
                particlePool.acquire(
                    this.x + this.width / 2,
                    this.originalY + this.floatOffset + this.height / 2,
                    color,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    30,
                    'sparkle'
                );
            }
        }
    }
    
    render(ctx, camera) {
        if (this.collected) {
            // Show respawn countdown
            const timeLeft = Math.ceil(this.respawnDuration - this.respawnTimer);
            if (timeLeft > 0) {
                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(timeLeft, this.x + this.width / 2 - camera.x, this.originalY + this.height / 2);
                ctx.restore();
            }
            return;
        }
        
        const renderX = this.x - camera.x;
        const renderY = this.originalY + this.floatOffset;
        
        ctx.save();
        
        // Draw glow effect
        const gradient = ctx.createRadialGradient(
            renderX + this.width / 2, renderY + this.height / 2, 0,
            renderX + this.width / 2, renderY + this.height / 2, this.width
        );
        const color = this.getColor();
        gradient.addColorStop(0, color + Math.floor(this.glowIntensity * 100).toString(16).padStart(2, '0'));
        gradient.addColorStop(1, color + '00');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(renderX - 10, renderY - 10, this.width + 20, this.height + 20);
        
        // Draw power-up icon
        ctx.fillStyle = color;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        
        switch (this.type) {
            case 'speed':
                // Lightning bolt
                ctx.beginPath();
                ctx.moveTo(renderX + this.width / 2, renderY + 5);
                ctx.lineTo(renderX + this.width / 2 - 5, renderY + this.height / 2);
                ctx.lineTo(renderX + this.width / 2 + 2, renderY + this.height / 2);
                ctx.lineTo(renderX + this.width / 2 - 3, renderY + this.height - 5);
                ctx.lineTo(renderX + this.width / 2 + 5, renderY + this.height / 2 - 2);
                ctx.lineTo(renderX + this.width / 2 - 2, renderY + this.height / 2 - 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;
                
            case 'invincibility':
                // Shield
                ctx.beginPath();
                ctx.moveTo(renderX + this.width / 2, renderY + 5);
                ctx.lineTo(renderX + this.width - 5, renderY + 10);
                ctx.lineTo(renderX + this.width - 5, renderY + this.height - 10);
                ctx.lineTo(renderX + this.width / 2, renderY + this.height - 5);
                ctx.lineTo(renderX + 5, renderY + this.height - 10);
                ctx.lineTo(renderX + 5, renderY + 10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;
                
            case 'doubleJump':
                // Double arrow up
                ctx.beginPath();
                ctx.moveTo(renderX + this.width / 2, renderY + 8);
                ctx.lineTo(renderX + this.width / 2 - 6, renderY + 14);
                ctx.lineTo(renderX + this.width / 2 + 6, renderY + 14);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(renderX + this.width / 2, renderY + 16);
                ctx.lineTo(renderX + this.width / 2 - 6, renderY + 22);
                ctx.lineTo(renderX + this.width / 2 + 6, renderY + 22);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;
                
            case 'slowMotion':
                // Clock
                ctx.beginPath();
                ctx.arc(renderX + this.width / 2, renderY + this.height / 2, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Clock hands
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(renderX + this.width / 2, renderY + this.height / 2);
                ctx.lineTo(renderX + this.width / 2, renderY + this.height / 2 - 6);
                ctx.moveTo(renderX + this.width / 2, renderY + this.height / 2);
                ctx.lineTo(renderX + this.width / 2 + 4, renderY + this.height / 2);
                ctx.stroke();
                break;
        }
        
        ctx.restore();
    }
    
    getColor() {
        switch (this.type) {
            case 'speed': return '#ffd93d'; // Yellow
            case 'invincibility': return '#4ecdc4'; // Blue
            case 'doubleJump': return '#95e1d3'; // Light blue
            case 'slowMotion': return '#ff6b6b'; // Red
            default: return '#ffffff';
        }
    }
}

// ===== POWER-UP MANAGER =====
class PowerUpManager {
    constructor() {
        this.activePowerUps = new Map();
        this.gameSpeedMultiplier = 1.0;
    }
    
    activatePowerUp(type, player) {
        const config = this.getPowerUpConfig(type);
        
        // If power-up is already active, refresh duration
        if (this.activePowerUps.has(type)) {
            const existing = this.activePowerUps.get(type);
            existing.remainingTime = config.duration;
        } else {
            // Activate new power-up
            this.activePowerUps.set(type, {
                type: type,
                duration: config.duration,
                remainingTime: config.duration,
                effect: config.effect
            });
            
            // Apply initial effect
            config.effect.apply(player, this);
        }
        
        // Play activation sound
        if (window.audioManager) {
            audioManager.playSound(type === 'invincibility' ? 'collect' : 'jump');
        }
    }
    
    update(deltaTime, player) {
        const toRemove = [];
        
        for (const [type, powerUp] of this.activePowerUps) {
            powerUp.remainingTime -= deltaTime;
            
            if (powerUp.remainingTime <= 0) {
                // Power-up expired
                toRemove.push(type);
                this.deactivatePowerUp(type, player);
            }
        }
        
        // Remove expired power-ups
        for (const type of toRemove) {
            this.activePowerUps.delete(type);
        }
    }
    
    deactivatePowerUp(type, player) {
        const config = this.getPowerUpConfig(type);
        if (config.deactivate) {
            config.deactivate(player, this);
        }
    }
    
    isActive(type) {
        return this.activePowerUps.has(type);
    }
    
    getRemainingTime(type) {
        const powerUp = this.activePowerUps.get(type);
        return powerUp ? powerUp.remainingTime : 0;
    }
    
    deactivateAll(player) {
        for (const [type, powerUp] of this.activePowerUps) {
            this.deactivatePowerUp(type, player);
        }
        this.activePowerUps.clear();
    }
    
    getPowerUpConfig(type) {
        const configs = {
            speed: {
                duration: 5,
                effect: {
                    apply: (player, manager) => {
                        player.speedMultiplier = 1.5;
                    }
                },
                deactivate: (player, manager) => {
                    player.speedMultiplier = 1.0;
                }
            },
            invincibility: {
                duration: 8,
                effect: {
                    apply: (player, manager) => {
                        player.invincible = true;
                    }
                },
                deactivate: (player, manager) => {
                    player.invincible = false;
                }
            },
            doubleJump: {
                duration: 10,
                effect: {
                    apply: (player, manager) => {
                        player.hasDoubleJump = true;
                        player.doubleJumpAvailable = true;
                    }
                },
                deactivate: (player, manager) => {
                    player.hasDoubleJump = false;
                    player.doubleJumpAvailable = false;
                }
            },
            slowMotion: {
                duration: 4,
                effect: {
                    apply: (player, manager) => {
                        manager.gameSpeedMultiplier = 0.5;
                    }
                },
                deactivate: (player, manager) => {
                    manager.gameSpeedMultiplier = 1.0;
                }
            }
        };
        
        return configs[type] || { duration: 0, effect: { apply: () => {} } };
    }
    
    getGameSpeedMultiplier() {
        return this.gameSpeedMultiplier;
    }
}

// ===== OBSTACLE SYSTEM =====
class Obstacle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.active = true;
        this.dangerous = false;
    }
    
    update(deltaTime) {
        // Override in subclasses
    }
    
    render(ctx, camera) {
        // Override in subclasses
    }
    
    checkCollision(player) {
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }
    
    applyEffect(player) {
        // Override in subclasses
    }
}

class MovingPlatform extends Obstacle {
    constructor(x, y, width, height, path, speed) {
        super(x, y, 'movingPlatform');
        this.width = width;
        this.height = height;
        this.path = path; // Array of {x, y} waypoints
        this.speed = speed;
        this.currentPathIndex = 0;
        this.direction = 1; // 1 for forward, -1 for reverse
        this.velocity = { x: 0, y: 0 };
        this.dangerous = false;
        
        // Calculate initial velocity
        if (path && path.length > 1) {
            this.updateVelocity();
        }
    }
    
    update(deltaTime) {
        if (!this.path || this.path.length < 2) return;
        
        // Move toward current target
        this.x += this.velocity.x * deltaTime * 60;
        this.y += this.velocity.y * deltaTime * 60;
        
        // Check if reached current waypoint
        const target = this.path[this.currentPathIndex];
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.speed) {
            // Reached waypoint, move to next
            if (this.direction === 1) {
                this.currentPathIndex++;
                if (this.currentPathIndex >= this.path.length) {
                    // Reached end, reverse
                    this.currentPathIndex = this.path.length - 2;
                    this.direction = -1;
                }
            } else {
                this.currentPathIndex--;
                if (this.currentPathIndex < 0) {
                    // Reached start, go forward
                    this.currentPathIndex = 1;
                    this.direction = 1;
                }
            }
            
            this.updateVelocity();
        }
    }
    
    updateVelocity() {
        const target = this.path[this.currentPathIndex];
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            this.velocity.x = (dx / distance) * this.speed;
            this.velocity.y = (dy / distance) * this.speed;
        }
    }
    
    applyVelocityToPlayer(player) {
        // Apply platform velocity to player when standing on it
        player.x += this.velocity.x * (1/60) * 60;
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        // Platform
        ctx.fillStyle = '#2a2a4e';
        ctx.fillRect(renderX, this.y, this.width, this.height);
        
        // Border
        ctx.strokeStyle = '#4a4a8e';
        ctx.lineWidth = 2;
        ctx.strokeRect(renderX, this.y, this.width, this.height);
        
        // Motion trail effect
        if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
            ctx.fillStyle = 'rgba(74, 74, 142, 0.3)';
            ctx.fillRect(
                renderX - this.velocity.x * 2,
                this.y - this.velocity.y * 2,
                this.width,
                this.height
            );
        }
        
        ctx.restore();
    }
}

class LaserHazard extends Obstacle {
    constructor(x, y, direction, cycleTime, warningTime, activeTime) {
        super(x, y, 'laser');
        this.direction = direction; // 'horizontal' or 'vertical'
        this.length = direction === 'horizontal' ? 200 : 150;
        this.width = direction === 'horizontal' ? this.length : 10;
        this.height = direction === 'horizontal' ? 10 : this.length;
        this.cycleTime = cycleTime || 3;
        this.warningTime = warningTime || 1;
        this.activeTime = activeTime || 1;
        this.currentTime = 0;
        this.currentPhase = 'inactive'; // 'inactive', 'warning', 'active'
        this.dangerous = false;
    }
    
    update(deltaTime) {
        this.currentTime += deltaTime;
        
        const totalCycle = this.cycleTime;
        const timeInCycle = this.currentTime % totalCycle;
        
        if (timeInCycle < this.warningTime) {
            this.currentPhase = 'warning';
            this.dangerous = false;
        } else if (timeInCycle < this.warningTime + this.activeTime) {
            this.currentPhase = 'active';
            this.dangerous = true;
        } else {
            this.currentPhase = 'inactive';
            this.dangerous = false;
        }
    }
    
    checkCollision(player) {
        if (!this.dangerous) return false;
        
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }
    
    applyEffect(player) {
        if (this.dangerous && !player.invincible) {
            player.die();
        }
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        if (this.currentPhase === 'warning') {
            // Flashing red warning
            const flash = Math.sin(Date.now() / 100) > 0 ? 0.6 : 0.3;
            ctx.fillStyle = `rgba(255, 100, 100, ${flash})`;
            ctx.fillRect(renderX, this.y, this.width, this.height);
            
            // Warning border
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(renderX, this.y, this.width, this.height);
        } else if (this.currentPhase === 'active') {
            // Active laser beam
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(renderX, this.y, this.width, this.height);
            
            // Glow effect
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillRect(renderX, this.y, this.width, this.height);
            
            // Spawn particles occasionally
            if (Math.random() < 0.3 && window.particles) {
                particles.push(new Particle(
                    this.x + Math.random() * this.width,
                    this.y + Math.random() * this.height,
                    '#ff6666',
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    10,
                    'sparkle'
                ));
            }
        } else {
            // Inactive - show faint outline
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(renderX, this.y, this.width, this.height);
        }
        
        ctx.restore();
    }
}

class SpikeTrap extends Obstacle {
    constructor(x, y, orientation) {
        super(x, y, 'spike');
        this.orientation = orientation || 'up'; // 'up', 'down', 'left', 'right'
        this.width = orientation === 'left' || orientation === 'right' ? 20 : 40;
        this.height = orientation === 'up' || orientation === 'down' ? 20 : 40;
        this.dangerous = true;
        this.damage = 1;
        this.knockbackForce = 8;
    }
    
    checkCollision(player) {
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }
    
    applyEffect(player) {
        if (player.invincible) return;
        
        // Apply knockback based on orientation
        switch (this.orientation) {
            case 'up':
                player.vy = -this.knockbackForce;
                break;
            case 'down':
                player.vy = this.knockbackForce;
                break;
            case 'left':
                player.vx = -this.knockbackForce;
                break;
            case 'right':
                player.vx = this.knockbackForce;
                break;
        }
        
        // Apply damage
        player.die();
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        // Draw spike base
        ctx.fillStyle = '#666666';
        ctx.fillRect(renderX, this.y, this.width, this.height);
        
        // Draw spikes
        ctx.fillStyle = '#ff4444';
        ctx.strokeStyle = '#cc0000';
        ctx.lineWidth = 1;
        
        const spikeCount = this.orientation === 'up' || this.orientation === 'down' ? 4 : 3;
        const spikeWidth = this.width / spikeCount;
        const spikeHeight = this.height / spikeCount;
        
        for (let i = 0; i < spikeCount; i++) {
            ctx.beginPath();
            
            switch (this.orientation) {
                case 'up':
                    ctx.moveTo(renderX + i * spikeWidth, this.y + this.height);
                    ctx.lineTo(renderX + (i + 0.5) * spikeWidth, this.y);
                    ctx.lineTo(renderX + (i + 1) * spikeWidth, this.y + this.height);
                    break;
                case 'down':
                    ctx.moveTo(renderX + i * spikeWidth, this.y);
                    ctx.lineTo(renderX + (i + 0.5) * spikeWidth, this.y + this.height);
                    ctx.lineTo(renderX + (i + 1) * spikeWidth, this.y);
                    break;
                case 'left':
                    ctx.moveTo(renderX + this.width, this.y + i * spikeHeight);
                    ctx.lineTo(renderX, this.y + (i + 0.5) * spikeHeight);
                    ctx.lineTo(renderX + this.width, this.y + (i + 1) * spikeHeight);
                    break;
                case 'right':
                    ctx.moveTo(renderX, this.y + i * spikeHeight);
                    ctx.lineTo(renderX + this.width, this.y + (i + 0.5) * spikeHeight);
                    ctx.lineTo(renderX, this.y + (i + 1) * spikeHeight);
                    break;
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

class ObstacleManager {
    constructor() {
        this.obstacles = [];
    }
    
    addObstacle(obstacle) {
        this.obstacles.push(obstacle);
    }
    
    updateAll(deltaTime) {
        for (const obstacle of this.obstacles) {
            if (obstacle.update) {
                obstacle.update(deltaTime);
            }
        }
    }
    
    renderAll(ctx, camera) {
        for (const obstacle of this.obstacles) {
            if (obstacle.render) {
                obstacle.render(ctx, camera);
            }
        }
    }
    
    checkCollisions(player) {
        for (const obstacle of this.obstacles) {
            if (obstacle.checkCollision && obstacle.checkCollision(player)) {
                if (obstacle.applyEffect) {
                    obstacle.applyEffect(player);
                }
            }
        }
    }
}

class LevelManager {
    constructor() {
        this.currentLevel = 1;
        this.levels = new Map();
        this.transitioning = false;
    }
    
    loadLevel(levelNumber) {
        this.currentLevel = levelNumber;
        const config = this.levels.get(levelNumber);
        return config;
    }
    
    completeLevel() {
        this.currentLevel++;
    }
    
    resetLevel() {
        // Reset to current level
    }
    
    getCurrentLevel() {
        return this.currentLevel;
    }
    
    addLevelConfig(levelNumber, config) {
        this.levels.set(levelNumber, config);
    }
}

class Checkpoint {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 60;
        this.activated = false;
    }
    
    activate() {
        if (!this.activated) {
            this.activated = true;
            // Spawn activation particles
            if (window.particles) {
                const sparkles = ParticleFactory.createSparkleParticles(
                    this.x + this.width / 2,
                    this.y + this.height / 2,
                    12
                );
                particles.push(...sparkles);
            }
            // Play sound
            if (window.audioManager) {
                audioManager.playSound('collect');
            }
        }
    }
    
    checkCollision(player) {
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }
    
    isActivated() {
        return this.activated;
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        if (this.activated) {
            ctx.fillStyle = '#00ff00';
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
        } else {
            ctx.fillStyle = '#888888';
        }
        
        // Flag pole
        ctx.fillRect(renderX + this.width / 2 - 2, this.y, 4, this.height);
        
        // Flag
        ctx.beginPath();
        ctx.moveTo(renderX + this.width / 2, this.y + 10);
        ctx.lineTo(renderX + this.width / 2 + 20, this.y + 20);
        ctx.lineTo(renderX + this.width / 2, this.y + 30);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
}

class FallingPlatform extends Obstacle {
    constructor(x, y, width, height) {
        super(x, y, 'fallingPlatform');
        this.width = width;
        this.height = height;
        this.fallDelay = 0.5;
        this.fallTimer = 0;
        this.falling = false;
        this.fallSpeed = 0;
        this.respawnTime = 5;
        this.respawnTimer = 0;
        this.originalY = y;
        this.playerOnPlatform = false;
        this.dangerous = false;
    }
    
    update(deltaTime) {
        if (this.falling) {
            // Accelerate downward
            this.fallSpeed += GRAVITY * 2;
            this.y += this.fallSpeed;
            
            // Check if off-screen
            if (this.y > CANVAS_HEIGHT + 100) {
                this.falling = false;
                this.respawnTimer = 0;
            }
        } else if (this.y > this.originalY) {
            // Respawning
            this.respawnTimer += deltaTime;
            if (this.respawnTimer >= this.respawnTime) {
                this.y = this.originalY;
                this.fallSpeed = 0;
                this.fallTimer = 0;
                this.respawnTimer = 0;
            }
        } else if (this.playerOnPlatform && !this.falling) {
            // Player on platform, start fall timer
            this.fallTimer += deltaTime;
            if (this.fallTimer >= this.fallDelay) {
                this.falling = true;
            }
        }
        
        // Reset player on platform flag (will be set by collision detection)
        this.playerOnPlatform = false;
    }
    
    startFallTimer() {
        if (!this.falling && this.y === this.originalY) {
            this.playerOnPlatform = true;
        }
    }
    
    cancelFallTimer() {
        if (!this.falling) {
            this.fallTimer = 0;
            this.playerOnPlatform = false;
        }
    }
    
    render(ctx, camera) {
        if (this.y > CANVAS_HEIGHT) return; // Don't render if off-screen
        
        const renderX = this.x - camera.x;
        
        ctx.save();
        
        // Platform color based on state
        let alpha = 1.0;
        if (this.fallTimer > 0 && !this.falling) {
            // Crumbling - flash and fade
            alpha = 1.0 - (this.fallTimer / this.fallDelay) * 0.5;
            if (Math.sin(Date.now() / 100) > 0) {
                alpha *= 0.7;
            }
        } else if (this.y > this.originalY) {
            // Respawning - fade in
            alpha = Math.min(this.respawnTimer / this.respawnTime, 1.0);
        }
        
        ctx.fillStyle = `rgba(100, 100, 120, ${alpha})`;
        ctx.fillRect(renderX, this.y, this.width, this.height);
        
        // Border
        ctx.strokeStyle = `rgba(150, 150, 170, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(renderX, this.y, this.width, this.height);
        
        // Cracks if about to fall
        if (this.fallTimer > 0 && !this.falling) {
            ctx.strokeStyle = `rgba(200, 100, 100, ${alpha})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(renderX + this.width * 0.3, this.y);
            ctx.lineTo(renderX + this.width * 0.3, this.y + this.height);
            ctx.moveTo(renderX + this.width * 0.7, this.y);
            ctx.lineTo(renderX + this.width * 0.7, this.y + this.height);
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// ===== PLAYER CLASS =====
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 40;
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
        this.sprite = new Image();
        this.sprite.src = '/static/kiro-logo.png';
        this.checkpointX = x;
        this.checkpointY = y;
        
        // Enhanced movement physics
        this.acceleration = 0.8;
        this.airAcceleration = 0.4;
        this.maxSpeed = MOVE_SPEED;
        this.groundFriction = 0.85;
        this.airFriction = 0.95;
        this.targetVx = 0;
        
        // Coyote time (grace period for jumping after leaving platform)
        this.coyoteTime = 0.1; // seconds
        this.coyoteTimer = 0;
        this.wasOnGround = false;
        
        // Jump buffering (remember jump input before landing)
        this.jumpBufferTime = 0.1; // seconds
        this.jumpBufferTimer = 0;
        
        // Variable jump height
        this.isJumping = false;
        this.jumpReleaseGravityMultiplier = 1.5;
        
        // Landing detection
        this.justLanded = false;
        this.previousVy = 0;
        
        // Animation state
        this.animationState = 'idle';
        this.idleTimer = 0;
        this.runningTimer = 0;
        
        // Time warp history
        this.history = [];
        this.historyMaxFrames = Math.floor(TIME_WARP_HISTORY_SECONDS * 60);
        this.isRewinding = false;
        this.rewindIndex = 0;
        
        // Power-up properties
        this.speedMultiplier = 1.0;
        this.invincible = false;
        this.hasDoubleJump = false;
        this.doubleJumpAvailable = false;
        this.wasJumpPressed = false;
        
        // Moving platform tracking
        this.lastPlatform = null;
    }
    
    update(platforms) {
        if (this.isRewinding) {
            this.updateRewind();
            return;
        }
        
        // Record history
        this.history.push({
            x: this.x,
            y: this.y,
            vx: this.vx,
            vy: this.vy
        });
        
        if (this.history.length > this.historyMaxFrames) {
            this.history.shift();
        }
        
        // Horizontal movement with acceleration
        const effectiveMaxSpeed = this.maxSpeed * this.speedMultiplier;
        
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            this.targetVx = -effectiveMaxSpeed;
        } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            this.targetVx = effectiveMaxSpeed;
        } else {
            this.targetVx = 0;
        }
        
        // Apply acceleration (different for ground vs air)
        const accel = this.onGround ? this.acceleration : this.airAcceleration;
        const friction = this.onGround ? this.groundFriction : this.airFriction;
        
        if (this.targetVx !== 0) {
            // Accelerate toward target speed
            const diff = this.targetVx - this.vx;
            this.vx += diff * accel;
            
            // Quick turnaround when changing direction
            if (Math.sign(this.targetVx) !== Math.sign(this.vx) && Math.abs(this.vx) > 0.5) {
                this.vx *= 0.7; // Reduce velocity faster when turning
            }
        } else {
            // Apply friction when no input
            this.vx *= friction;
            
            // Stop completely if velocity is very small
            if (Math.abs(this.vx) < 0.1) {
                this.vx = 0;
            }
        }
        
        // Clamp to max speed
        if (Math.abs(this.vx) > effectiveMaxSpeed) {
            this.vx = Math.sign(this.vx) * effectiveMaxSpeed;
        }
        
        // Update coyote time
        if (this.onGround) {
            this.coyoteTimer = this.coyoteTime;
            this.wasOnGround = true;
        } else if (this.wasOnGround) {
            // Just left the ground, start coyote timer
            this.coyoteTimer -= 1 / 60; // Assuming 60 FPS
            if (this.coyoteTimer <= 0) {
                this.wasOnGround = false;
            }
        }
        
        // Update jump buffer timer
        if (this.jumpBufferTimer > 0) {
            this.jumpBufferTimer -= 1 / 60;
        }
        
        // Check for jump input
        const jumpPressed = keys[' '] || keys['ArrowUp'] || keys['w'] || keys['W'];
        
        // Buffer jump input if pressed while in air
        if (jumpPressed && !this.onGround && this.coyoteTimer <= 0) {
            this.jumpBufferTimer = this.jumpBufferTime;
        }
        
        // Execute jump if conditions are met
        const canJump = this.onGround || this.coyoteTimer > 0;
        const canDoubleJump = this.hasDoubleJump && this.doubleJumpAvailable && !this.onGround && this.coyoteTimer <= 0;
        const shouldJump = (jumpPressed && canJump) || (this.jumpBufferTimer > 0 && this.onGround);
        const shouldDoubleJump = jumpPressed && canDoubleJump && !this.wasJumpPressed;
        
        if (shouldJump) {
            this.vy = -JUMP_POWER;
            this.onGround = false;
            this.coyoteTimer = 0;
            this.wasOnGround = false;
            this.jumpBufferTimer = 0;
            this.isJumping = true;
            
            // Transfer momentum from moving platform
            if (this.lastPlatform && this.lastPlatform.velocity) {
                // Add a portion of the platform's horizontal velocity to player
                this.vx += this.lastPlatform.velocity.x * 0.5;
            }
            
            // Play jump sound
            if (typeof audioManager !== 'undefined') {
                audioManager.playSound('jump');
            }
        } else if (shouldDoubleJump) {
            // Double jump
            this.vy = -JUMP_POWER;
            this.doubleJumpAvailable = false;
            this.isJumping = true;
            
            // Spawn double jump particles
            const sparkleParticles = ParticleFactory.createSparkleParticles(
                this.x + this.width / 2,
                this.y + this.height / 2,
                12
            );
            particles.push(...sparkleParticles);
            
            // Play jump sound
            if (typeof audioManager !== 'undefined') {
                audioManager.playSound('jump');
            }
        }
        
        // Track jump button state for double jump
        this.wasJumpPressed = jumpPressed;
        
        // Track if jump button is released
        if (!jumpPressed && this.isJumping) {
            this.isJumping = false;
        }
        
        // Time Warp activation
        if (keys['e'] || keys['E']) {
            if (timeWarpsRemaining > 0 && !this.isRewinding && this.history.length > 30) {
                this.startRewind();
                keys['e'] = false;
                keys['E'] = false;
            }
        }
        
        // Apply gravity with variable jump height
        let gravityMultiplier = 1;
        
        // Apply stronger gravity when falling or when jump button released early
        if (this.vy > 0) {
            // Falling - apply stronger gravity for snappier feel
            gravityMultiplier = this.jumpReleaseGravityMultiplier;
        } else if (this.vy < 0 && !jumpPressed && !this.isJumping) {
            // Rising but jump button not held - cut jump short
            gravityMultiplier = this.jumpReleaseGravityMultiplier;
        }
        
        this.vy += GRAVITY * gravityMultiplier;
        
        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;
        
        // Generate trail particles during movement
        const velocityMagnitude = Math.sqrt(this.vx ** 2 + this.vy ** 2);
        if (velocityMagnitude > 1 && Math.random() < 0.3) {
            const trailParticle = ParticleFactory.createTrailParticle(
                this.x + this.width / 2,
                this.y + this.height / 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            particles.push(trailParticle);
        }
        
        // Collision detection
        this.onGround = false;
        let standingOnMovingPlatform = null;
        
        for (const platform of platforms) {
            if (this.intersects(platform)) {
                // Vertical collision (landing on top or hitting bottom)
                if (this.vy > 0 && this.y + this.height - this.vy <= platform.y) {
                    // Landing on top
                    const landingSpeed = this.previousVy;
                    this.y = platform.y - this.height;
                    this.vy = 0;
                    this.onGround = true;
                    
                    // Track if standing on moving platform
                    if (platform.velocity && (platform.velocity.x !== 0 || platform.velocity.y !== 0)) {
                        standingOnMovingPlatform = platform;
                    }
                    
                    // Reset double jump on landing
                    if (this.hasDoubleJump) {
                        this.doubleJumpAvailable = true;
                    }
                    
                    // Landing effects (only trigger once per landing)
                    if (!this.justLanded && landingSpeed > 3) {
                        this.justLanded = true;
                        
                        // Scale effects based on fall speed
                        const impactIntensity = Math.min(landingSpeed / 15, 1);
                        const particleCount = Math.floor(8 + impactIntensity * 8);
                        
                        // Spawn landing particles
                        const explosionParticles = ParticleFactory.createExplosionParticles(
                            this.x + this.width / 2,
                            this.y + this.height,
                            particleCount
                        );
                        particles.push(...explosionParticles);
                        
                        // Trigger screen shake based on impact
                        const shakeIntensity = 3 + impactIntensity * 5;
                        screenShake.trigger(shakeIntensity, 0.2);
                        
                        // Play landing sound
                        if (typeof audioManager !== 'undefined') {
                            audioManager.playSound('land');
                        }
                    }
                } else if (this.vy < 0 && this.y - this.vy >= platform.y + platform.height) {
                    // Hitting bottom
                    this.y = platform.y + platform.height;
                    this.vy = 0;
                    
                    // Spawn explosion particles on ceiling hit
                    const explosionParticles = ParticleFactory.createExplosionParticles(
                        this.x + this.width / 2,
                        this.y,
                        8
                    );
                    particles.push(...explosionParticles);
                } else {
                    // Horizontal collision
                    if (this.vx > 0) {
                        this.x = platform.x - this.width;
                        
                        // Spawn explosion particles on right wall hit
                        const explosionParticles = ParticleFactory.createExplosionParticles(
                            this.x + this.width,
                            this.y + this.height / 2,
                            8
                        );
                        particles.push(...explosionParticles);
                    } else if (this.vx < 0) {
                        this.x = platform.x + platform.width;
                        
                        // Spawn explosion particles on left wall hit
                        const explosionParticles = ParticleFactory.createExplosionParticles(
                            this.x,
                            this.y + this.height / 2,
                            8
                        );
                        particles.push(...explosionParticles);
                    }
                    this.vx = 0;
                }
            }
        }
        
        // Apply moving platform velocity if standing on one
        if (standingOnMovingPlatform && this.onGround) {
            // Apply platform's horizontal velocity to player
            this.x += standingOnMovingPlatform.velocity.x * (1/60) * 60;
            
            // Handle vertical platform movement
            // If platform is moving up, move player with it
            if (standingOnMovingPlatform.velocity.y < 0) {
                this.y += standingOnMovingPlatform.velocity.y * (1/60) * 60;
            }
            // If platform is moving down, player will naturally fall with it due to gravity
            
            // Track the platform for momentum transfer on jump
            this.lastPlatform = standingOnMovingPlatform;
        } else if (!this.onGround) {
            // Clear last platform when in air
            this.lastPlatform = null;
        }
        
        // Update animation state
        if (!this.onGround) {
            this.animationState = this.vy < 0 ? 'jumping' : 'falling';
            this.idleTimer = 0;
            this.runningTimer = 0;
        } else if (Math.abs(this.vx) > 0.5) {
            this.animationState = 'running';
            this.idleTimer = 0;
            this.runningTimer += 1 / 60;
            
            // Spawn dust particles while running
            if (Math.random() < 0.15) {
                const dustParticle = ParticleFactory.createTrailParticle(
                    this.x + this.width / 2 + (Math.random() - 0.5) * this.width,
                    this.y + this.height,
                    (Math.random() - 0.5) * 1,
                    -Math.random() * 0.5,
                );
                particles.push(dustParticle);
            }
        } else {
            this.animationState = 'idle';
            this.idleTimer += 1 / 60;
            this.runningTimer = 0;
            
            // Spawn ambient floating particles when idle
            if (this.idleTimer > 1 && Math.random() < 0.02) {
                const floatParticle = ParticleFactory.createTrailParticle(
                    this.x + this.width / 2 + (Math.random() - 0.5) * this.width,
                    this.y + this.height / 2,
                    (Math.random() - 0.5) * 0.5,
                    -Math.random() * 0.3
                );
                particles.push(floatParticle);
            }
        }
        
        // Track velocity for next frame (for landing detection)
        this.previousVy = this.vy;
        
        // Reset landing flag when in air
        if (!this.onGround) {
            this.justLanded = false;
        }
        
        // Speed boost trail effect
        if (this.speedMultiplier > 1.0 && Math.abs(this.vx) > 1) {
            // Spawn yellow trail particles
            if (Math.random() < 0.5) {
                particles.push(new Particle(
                    this.x + this.width / 2 + (Math.random() - 0.5) * this.width,
                    this.y + this.height / 2 + (Math.random() - 0.5) * this.height,
                    '#ffd93d',
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    15,
                    'trail'
                ));
            }
        }
        
        // Death check
        if (this.y > CANVAS_HEIGHT + 100) {
            this.die();
        }
    }
    
    startRewind() {
        this.isRewinding = true;
        this.rewindIndex = this.history.length - 1;
        timeWarpsRemaining--;
        
        // Create time warp particles
        createParticles(this.x + this.width / 2, this.y + this.height / 2, '#790ECB', 20);
        
        // Play time warp sound
        if (typeof audioManager !== 'undefined') {
            audioManager.playSound('timeWarp');
        }
    }
    
    updateRewind() {
        if (this.rewindIndex <= 0) {
            this.isRewinding = false;
            return;
        }
        
        // Smoothly interpolate through history (rewind 2 frames per update for speed)
        this.rewindIndex -= 2;
        if (this.rewindIndex < 0) this.rewindIndex = 0;
        
        const state = this.history[this.rewindIndex];
        this.x = state.x;
        this.y = state.y;
        this.vx = state.vx;
        this.vy = state.vy;
        
        // Ghost trail effect
        if (Math.random() < 0.3) {
            particles.push(new Particle(
                this.x + this.width / 2,
                this.y + this.height / 2,
                '#790ECB',
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                20
            ));
        }
    }
    
    intersects(rect) {
        return this.x < rect.x + rect.width &&
               this.x + this.width > rect.x &&
               this.y < rect.y + rect.height &&
               this.y + this.height > rect.y;
    }
    
    die() {
        // Check invincibility
        if (this.invincible) {
            return; // No damage when invincible
        }
        
        lives--;
        screenShake.trigger(12, 0.4);
        createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ff0000', 15);
        
        // Play damage sound
        if (typeof audioManager !== 'undefined') {
            audioManager.playSound('damage');
        }
        
        if (lives <= 0) {
            gameState = 'gameOver';
        } else {
            this.respawn();
        }
    }
    
    respawn() {
        this.x = this.checkpointX;
        this.y = this.checkpointY;
        this.vx = 0;
        this.vy = 0;
        this.history = [];
    }
    
    setCheckpoint(x, y) {
        this.checkpointX = x;
        this.checkpointY = y;
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        // Apply subtle floating animation when idle
        let renderY = this.y;
        if (this.animationState === 'idle' && this.idleTimer > 0.5) {
            renderY += Math.sin(this.idleTimer * 3) * 2;
        }
        
        // Invincibility shield effect
        if (this.invincible) {
            const time = Date.now() / 1000;
            const pulseSize = 5 + Math.sin(time * 5) * 3;
            const pulseAlpha = 0.3 + Math.sin(time * 5) * 0.2;
            
            ctx.save();
            ctx.strokeStyle = `rgba(78, 205, 196, ${pulseAlpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
                renderX + this.width / 2,
                renderY + this.height / 2,
                this.width / 2 + pulseSize,
                0,
                Math.PI * 2
            );
            ctx.stroke();
            
            // Inner shield glow
            const gradient = ctx.createRadialGradient(
                renderX + this.width / 2, renderY + this.height / 2, 0,
                renderX + this.width / 2, renderY + this.height / 2, this.width / 2 + pulseSize
            );
            gradient.addColorStop(0, 'rgba(78, 205, 196, 0)');
            gradient.addColorStop(1, `rgba(78, 205, 196, ${pulseAlpha * 0.5})`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(
                renderX + this.width / 2,
                renderY + this.height / 2,
                this.width / 2 + pulseSize,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.restore();
        }
        
        // Draw sprite or fallback
        if (this.sprite.complete) {
            ctx.drawImage(this.sprite, renderX, renderY, this.width, this.height);
        } else {
            ctx.fillStyle = '#790ECB';
            ctx.fillRect(renderX, renderY, this.width, this.height);
        }
        
        // Rewind indicator
        if (this.isRewinding) {
            ctx.strokeStyle = '#790ECB';
            ctx.lineWidth = 3;
            ctx.strokeRect(renderX - 5, this.y - 5, this.width + 10, this.height + 10);
        }
    }
}

// ===== PLATFORM CLASS =====
class Platform {
    constructor(x, y, width, height, type = 'dashboard') {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = type;
    }
    
    render(ctx, camera) {
        const renderX = this.x - camera.x;
        
        // Platform styling based on type
        const colors = {
            dashboard: '#1a1a2e',
            pipeline: '#16213e',
            service: '#0f3460'
        };
        
        ctx.fillStyle = colors[this.type] || colors.dashboard;
        ctx.fillRect(renderX, this.y, this.width, this.height);
        
        // Border
        ctx.strokeStyle = '#790ECB';
        ctx.lineWidth = 2;
        ctx.strokeRect(renderX, this.y, this.width, this.height);
        
        // Grid pattern
        ctx.strokeStyle = '#790ECB33';
        ctx.lineWidth = 1;
        for (let i = 10; i < this.width; i += 20) {
            ctx.beginPath();
            ctx.moveTo(renderX + i, this.y);
            ctx.lineTo(renderX + i, this.y + this.height);
            ctx.stroke();
        }
    }
}

// ===== COLLECTIBLE CLASS =====
class Collectible {
    constructor(x, y, type = 'metric') {
        this.x = x;
        this.y = y;
        this.width = 20;
        this.height = 20;
        this.type = type;
        this.collected = false;
        this.bobOffset = Math.random() * Math.PI * 2;
    }
    
    update(frame) {
        // Bobbing animation
        this.renderY = this.y + Math.sin(frame * 0.1 + this.bobOffset) * 5;
    }
    
    render(ctx, camera) {
        if (this.collected) return;
        
        const renderX = this.x - camera.x;
        
        // Glow effect
        const gradient = ctx.createRadialGradient(
            renderX + this.width / 2, this.renderY + this.height / 2, 0,
            renderX + this.width / 2, this.renderY + this.height / 2, this.width
        );
        
        if (this.type === 'metric') {
            gradient.addColorStop(0, '#790ECB');
            gradient.addColorStop(1, '#790ECB00');
        } else {
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(1, '#00ffff00');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(renderX - 10, this.renderY - 10, this.width + 20, this.height + 20);
        
        // Core
        ctx.fillStyle = this.type === 'metric' ? '#790ECB' : '#00ffff';
        ctx.beginPath();
        ctx.arc(renderX + this.width / 2, this.renderY + this.height / 2, this.width / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ===== DEPLOY GATE CLASS =====
class DeployGate {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 60;
        this.height = 100;
    }
    
    render(ctx, camera, frame) {
        const renderX = this.x - camera.x;
        
        // Animated gate
        ctx.fillStyle = '#00ff00' + Math.floor(128 + Math.sin(frame * 0.1) * 127).toString(16).padStart(2, '0');
        ctx.fillRect(renderX, this.y, this.width, this.height);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(renderX, this.y, this.width, this.height);
        
        // Checkmark
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(renderX + 15, this.y + 50);
        ctx.lineTo(renderX + 25, this.y + 60);
        ctx.lineTo(renderX + 45, this.y + 40);
        ctx.stroke();
    }
}

// ===== CAMERA CLASS =====
class Camera {
    constructor() {
        this.x = 0;
        this.targetX = 0;
    }
    
    update(player) {
        // Center camera on player with boundaries
        this.targetX = player.x - CANVAS_WIDTH / 2 + player.width / 2;
        this.targetX = Math.max(0, Math.min(this.targetX, LEVEL_WIDTH - CANVAS_WIDTH));
        
        // Smooth lerp
        this.x += (this.targetX - this.x) * CAMERA_LERP;
    }
}

// ===== LEVEL SETUP =====
const scoreManager = new ScoreManager();
highScore = scoreManager.getHighScore(); // Load high score on initialization
const player = new Player(100, 400);
const camera = new Camera();
const platforms = [];
const collectibles = [];
const powerUpManager = new PowerUpManager();
const powerUps = [];
const checkpoints = [];
let activeCheckpoint = null;

// Make powerUpManager globally accessible
window.powerUpManager = powerUpManager;

// Ground and platforms
platforms.push(new Platform(0, 550, 800, 50, 'dashboard'));
platforms.push(new Platform(900, 550, 400, 50, 'pipeline'));
platforms.push(new Platform(1400, 450, 300, 30, 'service'));
platforms.push(new Platform(1800, 350, 250, 30, 'dashboard'));
platforms.push(new Platform(2150, 450, 200, 30, 'pipeline'));
platforms.push(new Platform(2450, 350, 300, 30, 'service'));
platforms.push(new Platform(2850, 450, 250, 30, 'dashboard'));
platforms.push(new Platform(3200, 550, 600, 50, 'pipeline'));

// Collectibles
collectibles.push(new Collectible(400, 480));
collectibles.push(new Collectible(1100, 480));
collectibles.push(new Collectible(1500, 380));
collectibles.push(new Collectible(1900, 280));
collectibles.push(new Collectible(2250, 380));
collectibles.push(new Collectible(2550, 280));
collectibles.push(new Collectible(2950, 380));
collectibles.push(new Collectible(3400, 480));
collectibles.push(new Collectible(3600, 480));

totalCollectibles = collectibles.length;

// Add power-ups to the level
powerUps.push(new PowerUp(600, 480, 'speed'));
powerUps.push(new PowerUp(1600, 380, 'invincibility'));
powerUps.push(new PowerUp(2300, 380, 'doubleJump'));
powerUps.push(new PowerUp(3000, 380, 'slowMotion'));

// Add obstacles
const obstacleManager = new ObstacleManager();

// Add moving platforms
const movingPlatform1 = new MovingPlatform(1000, 400, 100, 20, [
    { x: 1000, y: 400 },
    { x: 1200, y: 400 }
], 2);
obstacleManager.addObstacle(movingPlatform1);
platforms.push(movingPlatform1); // Also add to platforms for collision

const movingPlatform2 = new MovingPlatform(2600, 300, 100, 20, [
    { x: 2600, y: 300 },
    { x: 2600, y: 450 }
], 1.5);
obstacleManager.addObstacle(movingPlatform2);
platforms.push(movingPlatform2);

// Add laser hazards
obstacleManager.addObstacle(new LaserHazard(1300, 500, 'horizontal', 3, 1, 1));
obstacleManager.addObstacle(new LaserHazard(2100, 400, 'vertical', 4, 1, 1.5));

// Add spike traps
obstacleManager.addObstacle(new SpikeTrap(1700, 330, 'up'));
obstacleManager.addObstacle(new SpikeTrap(2800, 430, 'up'));

// Add falling platforms
const fallingPlatform1 = new FallingPlatform(2000, 400, 80, 20);
obstacleManager.addObstacle(fallingPlatform1);
platforms.push(fallingPlatform1);

// Make obstacleManager globally accessible
window.obstacleManager = obstacleManager;

// Level manager
const levelManager = new LevelManager();
let currentLevel = 1;

// Deploy gate
const deployGate = new DeployGate(3700, 450);

// ===== LEVEL 2 LOADING =====
function loadLevel2() {
    currentLevel = 2;
    
    // Clear level 1 content
    platforms.length = 0;
    collectibles.length = 0;
    powerUps.length = 0;
    checkpoints.length = 0;
    particles.length = 0;
    
    // Reset player position
    player.x = 100;
    player.y = 400;
    player.vx = 0;
    player.vy = 0;
    player.setCheckpoint(100, 400);
    player.history = [];
    activeCheckpoint = null;
    
    // Reset camera
    camera.x = 0;
    
    // Level 2 platforms - larger gaps, more challenging
    platforms.push(new Platform(0, 550, 200, 50, 'dashboard'));
    platforms.push(new Platform(350, 500, 120, 30, 'service'));
    platforms.push(new Platform(600, 450, 100, 30, 'pipeline'));
    platforms.push(new Platform(850, 400, 100, 30, 'dashboard'));
    platforms.push(new Platform(1100, 350, 120, 30, 'service'));
    platforms.push(new Platform(1400, 450, 100, 30, 'pipeline'));
    platforms.push(new Platform(1650, 400, 100, 30, 'dashboard'));
    platforms.push(new Platform(1900, 350, 120, 30, 'service'));
    platforms.push(new Platform(2200, 450, 100, 30, 'pipeline'));
    platforms.push(new Platform(2500, 400, 100, 30, 'dashboard'));
    platforms.push(new Platform(2800, 350, 120, 30, 'service'));
    platforms.push(new Platform(3100, 450, 100, 30, 'pipeline'));
    platforms.push(new Platform(3400, 400, 100, 30, 'dashboard'));
    platforms.push(new Platform(3700, 550, 400, 50, 'service'));
    
    // Level 2 collectibles - more than level 1
    collectibles.push(new Collectible(400, 470));
    collectibles.push(new Collectible(650, 420));
    collectibles.push(new Collectible(900, 370));
    collectibles.push(new Collectible(1150, 320));
    collectibles.push(new Collectible(1450, 420));
    collectibles.push(new Collectible(1700, 370));
    collectibles.push(new Collectible(1950, 320));
    collectibles.push(new Collectible(2250, 420));
    collectibles.push(new Collectible(2550, 370));
    collectibles.push(new Collectible(2850, 320));
    collectibles.push(new Collectible(3150, 420));
    collectibles.push(new Collectible(3450, 370));
    collectibles.push(new Collectible(3800, 480));
    collectibles.push(new Collectible(3900, 480));
    
    totalCollectibles = collectibles.length;
    
    // Level 2 power-ups
    powerUps.push(new PowerUp(500, 470, 'speed'));
    powerUps.push(new PowerUp(1250, 320, 'invincibility'));
    powerUps.push(new PowerUp(2050, 320, 'doubleJump'));
    powerUps.push(new PowerUp(2950, 320, 'slowMotion'));
    
    // Create new obstacle manager for level 2
    const obstacleManager2 = new ObstacleManager();
    
    // More moving platforms with complex paths
    const mp1 = new MovingPlatform(750, 300, 100, 20, [
        { x: 750, y: 300 },
        { x: 950, y: 300 }
    ], 2);
    obstacleManager2.addObstacle(mp1);
    platforms.push(mp1);
    
    const mp2 = new MovingPlatform(1250, 250, 100, 20, [
        { x: 1250, y: 250 },
        { x: 1250, y: 450 },
        { x: 1350, y: 450 }
    ], 1.5);
    obstacleManager2.addObstacle(mp2);
    platforms.push(mp2);
    
    const mp3 = new MovingPlatform(2350, 300, 100, 20, [
        { x: 2350, y: 300 },
        { x: 2350, y: 500 }
    ], 2);
    obstacleManager2.addObstacle(mp3);
    platforms.push(mp3);
    
    const mp4 = new MovingPlatform(3250, 250, 100, 20, [
        { x: 3250, y: 250 },
        { x: 3250, y: 400 }
    ], 1.8);
    obstacleManager2.addObstacle(mp4);
    platforms.push(mp4);
    
    // More laser hazards with varied timing
    obstacleManager2.addObstacle(new LaserHazard(550, 500, 'horizontal', 2.5, 0.8, 1));
    obstacleManager2.addObstacle(new LaserHazard(1500, 500, 'horizontal', 3, 1, 1.2));
    obstacleManager2.addObstacle(new LaserHazard(1800, 250, 'vertical', 3.5, 1, 1.5));
    obstacleManager2.addObstacle(new LaserHazard(2650, 500, 'horizontal', 2.8, 0.9, 1.1));
    obstacleManager2.addObstacle(new LaserHazard(3300, 300, 'vertical', 3.2, 1, 1.3));
    
    // More spike traps
    obstacleManager2.addObstacle(new SpikeTrap(700, 430, 'up'));
    obstacleManager2.addObstacle(new SpikeTrap(1550, 380, 'up'));
    obstacleManager2.addObstacle(new SpikeTrap(2300, 430, 'up'));
    obstacleManager2.addObstacle(new SpikeTrap(3050, 330, 'up'));
    
    // Falling platforms
    const fp1 = new FallingPlatform(1550, 300, 80, 20);
    obstacleManager2.addObstacle(fp1);
    platforms.push(fp1);
    
    const fp2 = new FallingPlatform(2650, 350, 80, 20);
    obstacleManager2.addObstacle(fp2);
    platforms.push(fp2);
    
    // Update global obstacle manager
    window.obstacleManager = obstacleManager2;
    
    // Checkpoints at strategic locations
    checkpoints.push(new Checkpoint(1000, 290));
    checkpoints.push(new Checkpoint(2000, 290));
    checkpoints.push(new Checkpoint(3000, 290));
    
    // Move deploy gate to end of level 2
    deployGate.x = 3900;
    deployGate.y = 450;
    
    console.log('Level 2 loaded!');
}

// ===== PARALLAX BACKGROUND =====
function renderBackground(ctx, camera, frame) {
    // Dark gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    gradient.addColorStop(0, '#0a0a0a');
    gradient.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Cloud shapes (parallax)
    ctx.fillStyle = '#16213e44';
    for (let i = 0; i < 5; i++) {
        const x = (i * 600 - camera.x * 0.3) % (CANVAS_WIDTH + 200) - 100;
        const y = 100 + i * 80;
        ctx.fillRect(x, y, 150, 60);
        ctx.fillRect(x + 30, y - 20, 90, 60);
    }
    
    // Grid floor
    ctx.strokeStyle = '#790ECB22';
    ctx.lineWidth = 1;
    for (let i = 0; i < CANVAS_WIDTH; i += 40) {
        ctx.beginPath();
        ctx.moveTo(i, CANVAS_HEIGHT - 100);
        ctx.lineTo(i, CANVAS_HEIGHT);
        ctx.stroke();
    }
}

// ===== HUD =====
function renderHUD(ctx) {
    const leftMargin = 20;
    const lineHeight = 30;
    let yPos = 30;
    
    ctx.font = '20px Courier New';
    
    // Score
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Score: ${score}`, leftMargin, yPos);
    yPos += lineHeight;
    
    // High score with visual distinction
    ctx.fillStyle = '#790ECB';
    ctx.fillText(`High Score: ${highScore}`, leftMargin, yPos);
    yPos += lineHeight + 10; // Extra spacing before next group
    
    // Lives
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Lives: ${lives}`, leftMargin, yPos);
    yPos += lineHeight;
    
    // Time Warps with icons
    ctx.fillText(`Time Warps: ${timeWarpsRemaining}`, leftMargin, yPos);
    
    // Time warp indicator icons (aligned to the right of the label)
    if (timeWarpsRemaining > 0) {
        ctx.fillStyle = '#790ECB';
        const iconStartX = leftMargin + 150; // Position after "Time Warps: " text
        for (let i = 0; i < timeWarpsRemaining; i++) {
            ctx.fillRect(iconStartX + i * 25, yPos - 15, 20, 20);
        }
    }
}

// ===== GAME OVER / COMPLETE SCREENS =====
function renderGameOver(ctx) {
    ctx.fillStyle = '#00000099';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 48px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('SYSTEM OUTAGE', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px Courier New';
    ctx.fillText('Press R to Restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    ctx.textAlign = 'left';
}

function renderLevelComplete(ctx) {
    const timeTaken = Math.floor((Date.now() - levelStartTime) / 1000);
    
    ctx.fillStyle = '#00000099';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#00ff00';
    ctx.font = 'bold 48px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('DEPLOY SUCCESSFUL!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px Courier New';
    ctx.fillText(`Time: ${timeTaken}s`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
    ctx.fillText(`Metrics: ${score} / ${totalCollectibles}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
    ctx.fillText(`Lives Remaining: ${lives}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);
    
    ctx.font = '24px Courier New';
    ctx.fillText('Press R to Replay', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 90);
    
    if (!window.scoreSubmitted) {
        ctx.font = '16px Courier New';
        ctx.fillStyle = '#790ECB';
        ctx.fillText('Score saved to leaderboard!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 120);
    }
    
    ctx.textAlign = 'left';
}

// ===== GAME LOOP =====
let frame = 0;

function gameLoop() {
    frame++;
    
    // Update and apply screen shake
    screenShake.update();
    const shakeOffset = screenShake.getOffset();
    
    ctx.save();
    ctx.translate(shakeOffset.x, shakeOffset.y);
    
    if (gameState === 'playing') {
        // Update power-up manager
        powerUpManager.update(1/60, player);
        
        // Update power-ups
        powerUps.forEach(p => p.update(1/60, player));
        
        // Update obstacles
        if (window.obstacleManager) {
            obstacleManager.updateAll(1/60);
            obstacleManager.checkCollisions(player);
        }
        
        // Update
        player.update(platforms);
        camera.update(player);
        
        collectibles.forEach(c => {
            c.update(frame);
            if (!c.collected && player.intersects(c)) {
                c.collected = true;
                score++;
                
                // Update high score if current score exceeds it
                const previousHighScore = highScore;
                if (score > highScore) {
                    highScore = score;
                    
                    // Trigger confetti on new high score (only once per game)
                    if (!confettiTriggered && score > previousHighScore) {
                        confettiTriggered = true;
                        const confettiParticles = ParticleFactory.createConfettiParticles(50);
                        particles.push(...confettiParticles);
                    }
                }
                
                // Spawn sparkle particles when collecting
                const sparkleParticles = ParticleFactory.createSparkleParticles(
                    c.x + c.width / 2,
                    c.y + c.height / 2,
                    8
                );
                particles.push(...sparkleParticles);
                
                // Play collect sound
                if (typeof audioManager !== 'undefined') {
                    audioManager.playSound('collect');
                }
            }
        });
        
        // Update particles and remove dead ones
        particles.forEach(p => p.update());
        
        // Remove particles with life <= 0
        for (let i = particles.length - 1; i >= 0; i--) {
            if (particles[i].life <= 0) {
                particles.splice(i, 1);
            }
        }
        
        // Limit particle count for performance
        if (particles.length > MAX_PARTICLES) {
            // Remove oldest particles (from the beginning of the array)
            particles.splice(0, particles.length - MAX_PARTICLES);
        }
        
        // Check checkpoint collisions
        checkpoints.forEach(checkpoint => {
            if (!checkpoint.activated && checkpoint.checkCollision(player)) {
                checkpoint.activate();
                player.setCheckpoint(checkpoint.x, checkpoint.y);
                activeCheckpoint = checkpoint;
            }
        });
        
        // Check deploy gate
        if (player.intersects(deployGate)) {
            if (currentLevel === 1) {
                // Transition to level 2
                gameState = 'levelTransition';
                setTimeout(() => {
                    loadLevel2();
                    gameState = 'playing';
                }, 2000);
            } else {
                // Final completion
                gameState = 'levelComplete';
                submitScore();
            }
        }
        
        // Render
        renderBackground(ctx, camera, frame);
        
        platforms.forEach(p => p.render(ctx, camera));
        collectibles.forEach(c => c.render(ctx, camera));
        deployGate.render(ctx, camera, frame);
        
        // Render obstacles (lasers, spikes)
        if (window.obstacleManager) {
            obstacleManager.renderAll(ctx, camera);
        }
        
        particles.forEach(p => p.render(ctx, camera));
        checkpoints.forEach(c => c.render(ctx, camera));
        player.render(ctx, camera);
        powerUps.forEach(p => p.render(ctx, camera));
        
        // Slow-motion visual filter
        if (powerUpManager.isActive('slowMotion')) {
            ctx.fillStyle = 'rgba(100, 100, 150, 0.2)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
        
    } else if (gameState === 'gameOver') {
        renderBackground(ctx, camera, frame);
        platforms.forEach(p => p.render(ctx, camera));
        renderGameOver(ctx);
    } else if (gameState === 'levelComplete') {
        renderBackground(ctx, camera, frame);
        platforms.forEach(p => p.render(ctx, camera));
        collectibles.forEach(c => c.render(ctx, camera));
        deployGate.render(ctx, camera, frame);
        player.render(ctx, camera);
        renderLevelComplete(ctx);
    }
    
    ctx.restore();
    
    // Render HUD after restore so it's not affected by screen shake
    if (gameState === 'playing') {
        renderHUD(ctx);
    }
    
    requestAnimationFrame(gameLoop);
}

function loadLevel2() {
    currentLevel = 2;
    
    // Clear existing level
    platforms.length = 0;
    collectibles.length = 0;
    powerUps.length = 0;
    particles.length = 0;
    obstacleManager.obstacles.length = 0;
    
    // Reset player
    player.x = 100;
    player.y = 400;
    player.vx = 0;
    player.vy = 0;
    lives = 3;
    camera.x = 0;
    
    // Level 2 platforms (larger gaps)
    platforms.push(new Platform(0, 550, 600, 50, 'pipeline'));
    platforms.push(new Platform(800, 550, 300, 50, 'service'));
    platforms.push(new Platform(1300, 450, 200, 30, 'dashboard'));
    platforms.push(new Platform(1700, 350, 150, 30, 'pipeline'));
    platforms.push(new Platform(2050, 450, 200, 30, 'service'));
    platforms.push(new Platform(2450, 350, 250, 30, 'dashboard'));
    platforms.push(new Platform(2900, 500, 200, 30, 'pipeline'));
    platforms.push(new Platform(3300, 550, 700, 50, 'service'));
    
    // Moving platforms
    const mp1 = new MovingPlatform(1150, 500, 120, 20, [
        { x: 1150, y: 500 },
        { x: 1150, y: 350 }
    ], 2);
    platforms.push(mp1);
    obstacleManager.addObstacle(mp1);
    
    const mp2 = new MovingPlatform(2300, 400, 100, 20, [
        { x: 2300, y: 400 },
        { x: 2700, y: 400 }
    ], 2.5);
    platforms.push(mp2);
    obstacleManager.addObstacle(mp2);
    
    // Collectibles (more than level 1)
    for (let i = 0; i < 12; i++) {
        collectibles.push(new Collectible(500 + i * 250, 300 + Math.random() * 100));
    }
    totalCollectibles = collectibles.length;
    
    // Power-ups
    powerUps.push(new PowerUp(900, 480, 'speed'));
    powerUps.push(new PowerUp(1800, 280, 'invincibility'));
    powerUps.push(new PowerUp(2500, 280, 'doubleJump'));
    
    // Lasers
    obstacleManager.addObstacle(new LaserHazard(1500, 500, 'horizontal', 3, 1, 1));
    obstacleManager.addObstacle(new LaserHazard(2200, 300, 'vertical', 4, 1, 1.5));
    obstacleManager.addObstacle(new LaserHazard(3100, 500, 'horizontal', 3.5, 1, 1));
    
    // Spikes
    obstacleManager.addObstacle(new SpikeTrap(1650, 330, 'up'));
    obstacleManager.addObstacle(new SpikeTrap(2400, 330, 'up'));
    obstacleManager.addObstacle(new SpikeTrap(2850, 480, 'up'));
    
    // Falling platforms
    const fp1 = new FallingPlatform(1900, 400, 100, 20);
    platforms.push(fp1);
    obstacleManager.addObstacle(fp1);
    
    // Deploy gate at end
    deployGate.x = 3800;
    deployGate.y = 450;
}

function renderLevelTransition(ctx) {
    ctx.fillStyle = '#000000dd';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#790ECB';
    ctx.font = 'bold 48px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('LEVEL 2', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px Courier New';
    ctx.fillText('Get Ready...', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
    ctx.textAlign = 'left';
}

function restartGame() {
    gameState = 'playing';
    score = 0;
    highScore = scoreManager.getHighScore(); // Reload high score
    confettiTriggered = false; // Reset confetti flag
    lives = 3;
    timeWarpsRemaining = MAX_TIME_WARPS;
    levelStartTime = Date.now();
    player.x = 100;
    player.y = 400;
    player.vx = 0;
    player.vy = 0;
    player.history = [];
    player.isRewinding = false;
    player.setCheckpoint(100, 400); // Reset checkpoint to start
    camera.x = 0;
    collectibles.forEach(c => c.collected = false);
    particles.length = 0;
    window.scoreSubmitted = false;
    
    // Reset checkpoints
    checkpoints.forEach(c => c.activated = false);
    activeCheckpoint = null;
    
    // Reset power-ups
    powerUpManager.deactivateAll(player);
    powerUps.forEach(p => {
        p.collected = false;
        p.respawnTimer = 0;
    });
}

// ===== BACKEND INTEGRATION =====
async function submitScore() {
    if (window.scoreSubmitted) return;
    window.scoreSubmitted = true;
    
    const timeTaken = Math.floor((Date.now() - levelStartTime) / 1000);
    const playerName = scoreManager.getCurrentPlayerName();
    
    // Save to Local Storage via ScoreManager
    const gameSession = {
        player: playerName,
        score: score,
        time: timeTaken,
        lives: lives
    };
    scoreManager.saveGameSession(gameSession);
    
    // Also submit to backend server
    try {
        const response = await fetch('/api/scores', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                player: playerName,
                score: score,
                time: timeTaken,
                lives: lives
            })
        });
        
        if (response.ok) {
            console.log('Score submitted successfully!');
        }
    } catch (error) {
        console.error('Failed to submit score:', error);
    }
}

// ===== GAME INITIALIZATION =====
function startMainGame() {
    // Reset any splash-related keyboard listeners
    gameLoop();
}

// Initialize splash screen, then start game
initSplashScreen(canvas, startMainGame);
